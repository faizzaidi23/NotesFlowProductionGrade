<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/noteflowproduction/RepositoryImplementation/17_RemainderRepositoryImplementation.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/noteflowproduction/RepositoryImplementation/17_RemainderRepositoryImplementation.kt" />
              <option name="originalContent" value="package com.example.noteflowproduction.RepositoryImplementation&#10;&#10;import com.example.noteflowproduction.Database.Note&#10;import com.example.noteflowproduction.Database.Reminder&#10;import com.example.noteflowproduction.Database.ReminderDao&#10;import com.example.noteflowproduction.Repositories.ReminderRepository&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;class ReminderRepositoryImplementation(private val reminderDao: ReminderDao) : ReminderRepository {&#10;&#10;    //To get all the reminders&#10;    override fun getAllReminders(): Flow&lt;List&lt;Reminder&gt;&gt; {&#10;        return reminderDao.showAllReminders()&#10;    }&#10;&#10;    //Add a reminder&#10;    override suspend fun addReminder(reminder: Reminder) {&#10;        reminderDao.addReminder(reminder = reminder)&#10;    }&#10;&#10;    //update a reminder&#10;    override suspend fun updateReminder(reminder: Reminder) {&#10;        reminderDao.updateReminder(reminder = reminder)&#10;    }&#10;&#10;    //delete a reminder&#10;    override suspend fun deleteReminder(reminder: Reminder) {&#10;        reminderDao.deleteReminder(reminder = reminder)&#10;    }&#10;&#10;    //get reminders for note&#10;    override fun getRemindersForNote(noteId: Int): Flow&lt;List&lt;Reminder&gt;&gt; {&#10;        return reminderDao.getRemindersForNote(noteId = noteId)&#10;    }&#10;&#10;    //get reminders for tag&#10;    override fun getRemindersForTag(tagId: Int): Flow&lt;List&lt;Reminder&gt;&gt; {&#10;        return reminderDao.getRemindersForTag(tagId = tagId)&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.noteflowproduction.RepositoryImplementation&#10;&#10;import com.example.noteflowproduction.Database.Note&#10;import com.example.noteflowproduction.Database.Reminder&#10;import com.example.noteflowproduction.Database.ReminderDao&#10;import com.example.noteflowproduction.Repositories.ReminderRepository&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;class ReminderRepositoryImplementation(private val reminderDao: ReminderDao) : ReminderRepository {&#10;&#10;    //To get all the reminders&#10;    override fun getAllReminders(): Flow&lt;List&lt;Reminder&gt;&gt; {&#10;        return reminderDao.showAllReminders()&#10;    }&#10;&#10;    //Add a reminder&#10;    override suspend fun addReminder(reminder: Reminder) {&#10;        reminderDao.addReminder(reminder = reminder)&#10;    }&#10;&#10;    //update a reminder&#10;    override suspend fun updateReminder(reminder: Reminder) {&#10;        reminderDao.updateReminder(reminder = reminder)&#10;    }&#10;&#10;    //delete a reminder&#10;    override suspend fun deleteReminder(reminder: Reminder) {&#10;        reminderDao.deleteReminder(reminder = reminder)&#10;    }&#10;&#10;    //get reminders for note&#10;    override fun getRemindersForNote(noteId: Int): Flow&lt;List&lt;Reminder&gt;&gt; {&#10;        return reminderDao.getRemindersForNote(noteId = noteId)&#10;    }&#10;&#10;    //get reminders for tag&#10;    override fun getRemindersForTag(tagId: Int): Flow&lt;List&lt;Reminder&gt;&gt; {&#10;        return reminderDao.getRemindersForTag(tagId = tagId)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/noteflowproduction/ViewModels/22_TagViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/noteflowproduction/ViewModels/22_TagViewModel.kt" />
              <option name="originalContent" value="package com.example.noteflowproduction.ViewModels&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.noteflowproduction.Database.Note&#10;import com.example.noteflowproduction.Database.Tag&#10;import com.example.noteflowproduction.Repositories.tagRepository&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;/*&#10;&#10;This file the TagViewModel is the state Holder and business logic executor for the application&#10;its primary job is to manage the flow of the data between the tagRepository the data source&#10;and the UI jetpack compose ensuring the UI always displays the current, correct state of the tags&#10;&#10;*/&#10;&#10;@HiltViewModel&#10;class TagViewModel @Inject constructor(&#10;    private val tagRepository: tagRepository&#10;) : ViewModel() {&#10;&#10;&#10;    private val _allTags = MutableStateFlow&lt;List&lt;Tag&gt;&gt;(emptyList())&#10;    val allTags: StateFlow&lt;List&lt;Tag&gt;&gt; = _allTags.asStateFlow()&#10;&#10;&#10;    private val _selectedTag = MutableStateFlow&lt;Tag?&gt;(null)&#10;    val selectedTag: StateFlow&lt;Tag?&gt; = _selectedTag.asStateFlow()&#10;&#10;&#10;    private val _tagsForNote = MutableStateFlow&lt;List&lt;Tag&gt;&gt;(emptyList())&#10;    val tagsForNote: StateFlow&lt;List&lt;Tag&gt;&gt; = _tagsForNote.asStateFlow()&#10;&#10;&#10;    private val _notesForTag = MutableStateFlow&lt;List&lt;Note&gt;&gt;(emptyList())&#10;    val notesForTag: StateFlow&lt;List&lt;Note&gt;&gt; = _notesForTag.asStateFlow()&#10;&#10;    init {&#10;        loadAllTags()&#10;    }&#10;&#10;&#10;    private fun loadAllTags() {&#10;        viewModelScope.launch {&#10;            tagRepository.getAllTags().collect { tags -&gt;&#10;                _allTags.value = tags&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;    fun addTag(tag: Tag) {&#10;        viewModelScope.launch {&#10;            tagRepository.addTag(tag)&#10;        }&#10;    }&#10;&#10;&#10;    fun updateTag(tag: Tag) {&#10;        viewModelScope.launch {&#10;            tagRepository.updateTag(tag)&#10;        }&#10;    }&#10;&#10;&#10;    fun deleteTag(tag: Tag) {&#10;        viewModelScope.launch {&#10;            tagRepository.deleteTag(tag)&#10;        }&#10;    }&#10;&#10;&#10;    fun getTagsForNote(noteId: Int) {&#10;        viewModelScope.launch {&#10;            tagRepository.getAllTagsForNote(noteId).collect { tags -&gt;&#10;                _tagsForNote.value = tags&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;    fun getNotesForTag(tagId: Int) {&#10;        viewModelScope.launch {&#10;            tagRepository.getAllNotesForTag(tagId).collect { notes -&gt;&#10;                _notesForTag.value = notes&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;    fun selectTag(tag: Tag) {&#10;        _selectedTag.value = tag&#10;    }&#10;&#10;&#10;    fun clearSelectedTag() {&#10;        _selectedTag.value = null&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.noteflowproduction.ViewModels&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.noteflowproduction.Database.Note&#10;import com.example.noteflowproduction.Database.Tag&#10;import com.example.noteflowproduction.RepositoryImplementation.TagRepositoryImplementation&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;/*&#10;&#10;This file the TagViewModel is the state Holder and business logic executor for the application&#10;its primary job is to manage the flow of the data between the tagRepository the data source&#10;and the UI jetpack compose ensuring the UI always displays the current, correct state of the tags&#10;&#10;*/&#10;&#10;@HiltViewModel&#10;class TagViewModel @Inject constructor(&#10;    private val tagRepository: TagRepositoryImplementation&#10;) : ViewModel() {&#10;&#10;    // State for all tags---like when we want to have all the tags&#10;    private val _allTags = MutableStateFlow&lt;List&lt;Tag&gt;&gt;(emptyList())&#10;    val allTags: StateFlow&lt;List&lt;Tag&gt;&gt; = _allTags.asStateFlow()&#10;&#10;    //For one selected tag&#10;    private val _selectedTag = MutableStateFlow&lt;Tag?&gt;(null)&#10;    val selectedTag: StateFlow&lt;Tag?&gt; = _selectedTag.asStateFlow()&#10;&#10;    // Tags for a specific note&#10;    private val _tagsForNote = MutableStateFlow&lt;List&lt;Tag&gt;&gt;(emptyList())&#10;    val tagsForNote: StateFlow&lt;List&lt;Tag&gt;&gt; = _tagsForNote.asStateFlow()&#10;&#10;    // Notes for a specific tag&#10;    private val _notesForTag = MutableStateFlow&lt;List&lt;Note&gt;&gt;(emptyList())&#10;    val notesForTag: StateFlow&lt;List&lt;Note&gt;&gt; = _notesForTag.asStateFlow()&#10;&#10;    init {&#10;        loadAllTags()&#10;    }&#10;&#10;    // Load all tags--&gt; This function loads all the tags when we just open the app&#10;    private fun loadAllTags() {&#10;        viewModelScope.launch {&#10;            tagRepository.getAllTags().collect { tags -&gt;&#10;                _allTags.value = tags&#10;            }&#10;        }&#10;    }&#10;&#10;    // Add a new tag&#10;    fun addTag(tag: Tag) {&#10;        viewModelScope.launch {&#10;            tagRepository.addTag(tag)&#10;        }&#10;    }&#10;&#10;    // Update an existing tag&#10;    fun updateTag(tag: Tag) {&#10;        viewModelScope.launch {&#10;            tagRepository.updateTag(tag)&#10;        }&#10;    }&#10;&#10;    // Delete a tag&#10;    fun deleteTag(tag: Tag) {&#10;        viewModelScope.launch {&#10;            tagRepository.deleteTag(tag)&#10;        }&#10;    }&#10;&#10;    // Get all tags for a specific note&#10;    fun getTagsForNote(noteId: Int) {&#10;        viewModelScope.launch {&#10;            tagRepository.getAllTagsForNote(noteId).collect { tags -&gt;&#10;                _tagsForNote.value = tags&#10;            }&#10;        }&#10;    }&#10;&#10;    // Get all notes for a specific tag&#10;    fun getNotesForTag(tagId: Int) {&#10;        viewModelScope.launch {&#10;            tagRepository.getAllNotesForTag(tagId).collect { notes -&gt;&#10;                _notesForTag.value = notes&#10;            }&#10;        }&#10;    }&#10;&#10;    // Select a tag (when user clicks on a tag)&#10;    fun selectTag(tag: Tag) {&#10;        _selectedTag.value = tag&#10;    }&#10;&#10;    // Clear selected tag&#10;    fun clearSelectedTag() {&#10;        _selectedTag.value = null&#10;    }&#10;&#10;    // Link a tag to a note (many-to-many relationship)&#10;    fun addTagToNote(noteId: Int, tagId: Int) {&#10;        viewModelScope.launch {&#10;            tagRepository.addTagToNote(noteId, tagId)&#10;        }&#10;    }&#10;&#10;    // Unlink a tag from a note&#10;    fun removeTagFromNote(noteId: Int, tagId: Int) {&#10;        viewModelScope.launch {&#10;            tagRepository.removeTagFromNote(noteId, tagId)&#10;        }&#10;    }&#10;&#10;    // Clear all tags from a specific note&#10;    fun clearTagsForNote(noteId: Int) {&#10;        viewModelScope.launch {&#10;            tagRepository.clearTagsForNote(noteId)&#10;        }&#10;    }&#10;&#10;    // Clear all notes from a specific tag&#10;    fun clearNotesForTag(tagId: Int) {&#10;        viewModelScope.launch {&#10;            tagRepository.clearNotesForTag(tagId)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>